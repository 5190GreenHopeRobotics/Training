package frc.team5190.robot.drive

import com.ctre.phoenix.motorcontrol.ControlMode
import edu.wpi.first.wpilibj.Notifier
import edu.wpi.first.wpilibj.command.Command
import frc.team5190.robot.NavX
import jaci.pathfinder.Pathfinder
import jaci.pathfinder.followers.EncoderFollower
import java.io.File

// Class that follows a path generated by the Motion Profile Generator
class FollowPathCommand(folder: String, file: String) : Command() {

    // Proportional Gain (multiplied by error)
    private val p = 0.0

    // Integral Gain (multiplied by total accumulated error)
    private val i = 0.0

    // Derivative Gain (multiplied by difference in error over one time period)
    private val d = 0.0

    // Velocity Feed Forward (multiplied by pre-calculated speed)
    private val v = 0.0

    // Acceleration Feed Forward (multiplied by pre-calculated acceleration)
    private val a = 0.0


    // Trajectory for the left side of the robot. The file path is where paths are deployed to on the robot
    // file system.
    private val leftTrajectory = Pathfinder.readFromCSV(File("/home/lvuser/paths/$folder/${file}_left_detailed.csv"))

    // Trajectory for the right side of the robot
    private val rightTrajectory = Pathfinder.readFromCSV(File("/home/lvuser/paths/$folder/${file}_right_detailed.csv"))


    // Follower objects for each side of the robot. These objects will help in following the path by
    // calculating appropriate output based on encoder, gyro, gain values set above.
    private val leftEncoderFollower: EncoderFollower
    private val rightEncoderFollower: EncoderFollower

    // An object that runs code in a separate thread with a specific time interval between each consecutive
    // call. Accuracy is key to path following.
    private val notifier: Notifier


    // Initializer
    init {

        // Instantiate each follower with its respective trajectory
        leftEncoderFollower = EncoderFollower(leftTrajectory)
        rightEncoderFollower = EncoderFollower(rightTrajectory)

        // Configure settings for followers
        arrayListOf(leftEncoderFollower, rightEncoderFollower).forEach {encoderFollower ->
            encoderFollower.apply {
                configureEncoder(
                        0,          // Configure the starting encoder value as 0.
                        1440,   // The encoder resolution is 1440 ticks per revolution.
                        6 / 12.0   // The wheel diameter in feet.
                )
                configurePIDVA(p, i, d, v, a)   // Configure PIDVA gains set above.
            }
        }

        // Contains code that is to be run in every iteration of the path follower
        notifier = Notifier {
            // Get the calculated outputs from the followers. The current encoder values for each
            // side of the robot are passed as arguments for the calculate functions for each
            // follower.
            val leftBaseOutput = leftEncoderFollower.calculate(DriveSubsystem.leftPosition)
            val rightBaseOutput = rightEncoderFollower.calculate(DriveSubsystem.rightPosition)

            // Get the current heading of the robot
            val currentHeading = NavX.correctedAngle

            // Get the desired heading of the robot. Here we can use any follower's heading, because the headings
            // of the two followers will be approximately the same due to the shape of the robot.
            val desiredHeading = Pathfinder.r2d(leftEncoderFollower.heading)

            // Calculate the angle difference between desired and current heading.
            val angleDifference = Pathfinder.boundHalfDegrees(currentHeading - desiredHeading)

            // Get a turn value by multiplying a proportional gain by the angle difference. This turn value will
            // then be added to the base motor outputs that were calculated above for heading correction.
            val turn = 1.7 * (1 / 80.0) * angleDifference

            // Set the final motor outputs by adding and subtracting the turn value to the left and right
            // sides of the robot respectively.
            DriveSubsystem.set(ControlMode.PercentOutput, leftOutput = leftBaseOutput + turn, rightOutput = rightBaseOutput - turn)
        }
    }

    // This function is called when the command is called.
    override fun initialize() {
        // Reset the encoders back to 0.
        DriveSubsystem.resetEncoders()

        // Start the notifier with the same dt (time interval) as the path generator setting.
        notifier.startPeriodic(0.02)
    }

    // The command has finished when the two followers have finished following the path.
    override fun isFinished() = leftEncoderFollower.isFinished && rightEncoderFollower.isFinished
}